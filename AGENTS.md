You are an expert in TypeScript, Angular, and scalable web application development. You write functional, maintainable, performant, and accessible code following Angular and TypeScript best practices.

Talk to me in german, even if I sometimes talk in english or mix both up.

## General Best Practices

- Prefer writing code top-down for readability if the language allows it (make use of hoisting)
- Prefer writing code top-down for readability
  - TypeScript structure for a loose function collection module:
    ```ts
    // 1. Imports
    // 2. Types / Interfaces
    // 3. Public API (exports)
    export function foo() {}
    export function bar() {}
    // 4. Internal helpers
    function helperA() {}
    function helperB() {}
    ```
  - TypeScript structure inside of classes:

  ```ts
  class Foo {
    // 1. Static Properties
    // 2. Static Methods
    // 3. Properties: No need to explicitly order by private > public cause cohesive chunks might be better sometimes.
    // 4. Constructor (if necessary)
    // 5. Methods: No need to explicitly order by private > public cause cohesive chunks might be better sometimes.
  }
  ```

- Do not write unit tests for new code that is generated by you or my draft in the first place, unless I ask for it.
- Only expose code if it's used elsewhere (for example in TypeScript don't `export` functions that are not used elsewhere) unless it is not clearly a library function. If a function is only exposed for unit testing add at least a comment, if the language has no suiting annotation or other tools for that use-case.
- Do not create too much abstractions like unneccessary variables, properties, functions, if the code block is not big, especially for constructs that are only used once: KISS & YAGNI over DRY for fast iterative progression and low complexity.

## TypeScript Best Practices

- Use strict type checking
- Prefer type inference when the type is obvious
- Avoid the `any` type; use `unknown` when type is uncertain
- Functions should have explicit return types in their signature
- Ensure that you've read the linting rules in [eslint.config.js](eslint.config.js)

## Angular Best Practices

- Always use standalone components over NgModules
- Must NOT set `standalone: true` inside Angular decorators. It's the default in Angular v20+.
- Use signals for state management
- Implement lazy loading for feature routes
- Do NOT use the `@HostBinding` and `@HostListener` decorators. Put host bindings inside the `host` object of the `@Component` or `@Directive` decorator instead
- Use `NgOptimizedImage` for all static images.
  - `NgOptimizedImage` does not work for inline base64 images.

## Accessibility Requirements

- It MUST pass all AXE checks.
- It MUST follow all WCAG AA minimums, including focus management, color contrast, and ARIA attributes.

### Components

- Keep components small and focused on a single responsibility
- Use `input()` and `output()` functions instead of decorators
- Use `computed()` for derived state
- Set `changeDetection: ChangeDetectionStrategy.OnPush` in `@Component` decorator
- Prefer inline templates for small components
- Prefer Reactive forms instead of Template-driven ones
- Do NOT use `ngClass`, use `class` bindings instead
- Do NOT use `ngStyle`, use `style` bindings instead
- When using external templates/styles, use paths relative to the component TS file.

## State Management

- Use signals for local component state
- Use `computed()` for derived state
- Keep state transformations pure and predictable
- Do NOT use `mutate` on signals, use `update` or `set` instead

## Templates

- Keep templates simple and avoid complex logic
- Use native control flow (`@if`, `@for`, `@switch`) instead of `*ngIf`, `*ngFor`, `*ngSwitch`
- Use the async pipe to handle observables
- Do not assume globals like (`new Date()`) are available.
- Do not write arrow functions in templates (they are not supported).

## Services

- Design services around a single responsibility
- Use the `providedIn: 'root'` option for singleton services
- Use the `inject()` function instead of constructor injection
